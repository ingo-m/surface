% -------------------------------------------------------------------------
% The purpose of this script is to create design matrices containing rest
% blocks, stimulus blocks, and target events. More specifically, the
% occurence of target events should be orthogonal to the stimulus
% presentation (rest/stimulus-blocks). (Target events could for example be a
% change in colour of fixation cross, but also any other type of event -
% this needs to be implemented in the respective experiment script.) There
% are three or more types of events: rest (coded as 1), target (coded as
% 2), and one or more different stimuli (e.g. levels of stimulus contrast).
% If there are two or more stimulus levels, the order of the different
% stimuli is pseudo-random. Moreover, if there are three or more stimulus
% levels, an additional constraint is that the same type of stimulus event
% does not occur twice in succession.
% -------------------------------------------------------------------------
% Note: In this version, the possible rest block durations are multiples of
% the TR. In this way, rest blocks and stimulus blocks are in synchrony
% with the TR. There is another version of this script with a continuous
% range of possible rest block durations within a specified interval (i.e.
% rest block durations can take any value between for example 20 and 24
% seconds, also including non-integer values such as e.g. 21.738). That
% script is located at '.../2_LGN_FuncMap/scripts/'.
% -------------------------------------------------------------------------
% First, a design matrix (containing the stimulus events and the target
% events) is created. This design matrix is then convolved with a gamma
% function. The convolution of the design matrix and the gamma function is
% performed in the resolution of the design matrix ('var_tmp_res', e.g.
% with millisecond resolution).
% -------------------------------------------------------------------------
% The model of the gamma function is based on: Uludag et al. (2009). Basic
% principles of functional MRI
% -------------------------------------------------------------------------
% Ingo Marquardt, 13/12/2015
% -------------------------------------------------------------------------
tic;
%% Define names & path for output:
ary_prefix = {...
    'Run_01', ...
    'Run_02', ...
    'Run_03', ...
    'Run_04', ...
    'Run_05', ...
    'Run_06', ...
    'Run_07', ...
    'Run_08', ...
    'Run_09', ...
    'Run_10'};
% Retrieve the full file name of this script:
str_filename = mfilename('fullpath');
% Split the full file name into the path, the file name, and the extension:
[str_path, str_name, str_ext] = fileparts(str_filename);
% Delete the last 8 characters, which correspond to the subfolder
% containing this script. Important: This script has to be located in a
% directory with the appropriate number of characters in the name, e.g.
% '/scripts'.
str_path = str_path(1:(end-8));
str_output_path = [str_path, '/design_matrices/'];
%% Define parameters I:
% Temporal resolution of the design matrix: Temporal resolution of the
% design matrix in seconds. If this value is e.g. 0.001, this means that
% there is an entry in the design matrix for every 1 ms:
var_tmp_res = 0.001; % 0.001;
% Define correlation threshold: Maximmally acceptable correlation between
% predicted modulation from target & stimulus events:
var_cor_threshold = 0.001; % 0.001;
%% Create gamma function:
% The modelling of the gamma function is based on: Uludag et al. (2009).
% Basic principles of functional MRI Parameters of gamma function:
var_gamma_k = 3;
var_gamma_tau = 1.2;
% Duration over which the gamma function is modelled [s]:
var_dur_gamma = 40;
% Create model of gamma function:
vec_gamma_01 = linspace(...
    0, ...
    var_dur_gamma, ...
    ((var_dur_gamma / var_tmp_res) + 1)...
    );
for index_3 = 1:length(vec_gamma_01)
    vec_gamma_01(index_3) = ...
        1 / ...
        (var_gamma_k * ...
        var_gamma_tau * ...
        factorial(var_gamma_k-1)) ...
        * (vec_gamma_01(index_3) / ...
        var_gamma_tau) .^ ...
        var_gamma_k * ...
        exp( -(vec_gamma_01(index_3)) / var_gamma_tau);
end
% Scale gamma function to 1:
vec_gamma_01 = vec_gamma_01 ./ max(vec_gamma_01);
%% Main loop for automated creation of design matrices for several runs:
for index_9 = 1:numel(ary_prefix)
    str_prefix = ary_prefix{index_9};
    var_cor = 1;
    while abs(var_cor) > var_cor_threshold
        %% Define parameters II:
        % Duration of one volume TR in seconds
        var_TR = 1.947;
        % Duration of stimulus blocks in seconds:
        var_dur_blk_stim = (5.0 * var_TR);
        % We define a vector that contains the possible durations for the
        % rest block. The order of rest block durations will be randomised.
        % The number of rest block durations needs to be uneven (i.e. 1, 3,
        % 5, ...).
        vec_dur_blk_rest = [...
            9.0 * var_TR, ...
            10.0 * var_TR, ...
            11.0 * var_TR ...
            ];
        % The duration of the first rest block:
        var_dur_blk_rest_mean = mean(vec_dur_blk_rest);
        % Number of different durations that the rest blocks can have:
        var_num_rest_dur = numel(vec_dur_blk_rest);
        % Number of stimulus blocks:
        var_num_blk_stim = 12; % Needs to be an even number (for jitter)
        % Minimum interval (in seconds) between the onset of a target and
        % the onset of a new condition (rest or stimulus). (This is to
        % avoid problems with the timing of events (and their logging) in
        % the experiment script).
        var_int_trgt_blk = 0.5;
        % Minimum interval (in seconds) between the onset of a a new
        % condition (rest or stimulus) and the onset of a target. (This is
        % to avoid problems with the timing of events (and their logging)
        % in the experiment script).
        var_int_blk_trgt = 0.5;
        % Every stimulus block will be preceded by a rest block, and the
        % last stimulus block will be followed by an additional rest block:
        var_num_blk_rest = var_num_blk_stim + 1;
        var_dur_exp = ...
            (var_num_blk_stim * var_dur_blk_stim) + ...
            (var_num_blk_rest * var_dur_blk_rest_mean);
        disp(strcat(...
            'Duration of the experiment:_', num2str(var_dur_exp), 's' ...
            ));
        % Inter-trial-interval for the occurence of the target in seconds
        % (i.e. on average there'll be a target every x seconds):
        var_iti_target = 20.0;
        % Target jitter in seconds (i.e. the target will appear in a range
        % of x seconds before and after the average inter-trial duration):
        var_jit_target = 10.0;
        % This variable specifies that in the first and last x seconds of
        % the experiment there will be no targets:
        var_no_target = 15.0;
        % Duration of target in seconds. NOTE: This value is only used when
        % creating the event matrix. For the convolution of the design
        % matrix with the gamma function, target events are assumed to have
        % a duration of one time point:
        var_dur_target = 1.0;
        % The number of stimulus levels. In a parametric design, this
        % number is bigger than one, and the order of stimulus events in
        % the event matrix is pseudo-randomly permuted (with the condition
        % that the same stimulus level does not appear twice in
        % succession). If this number is set to one, this randomisation
        % procedure is ignored; in this way this script can be used for
        % simple block designs with just one level.
        var_stim_levels = 3;
        %% Create design matrix & preparations for jitter:
        % Number of time points in the design matrix. Note: The reason we
        % have to round here is that otherwise MATLAB does not represent
        % the result - i.e. var_num_timepoints - as an integer:
        var_num_timepoints = int64(round(var_dur_exp / var_tmp_res));
        % The design matrix: column 1 = stimuli, column 2 = target events,
        % colum 3 = timestamp in seconds (only used at the end of this
        % script):
        mat_design = zeros(var_num_timepoints, 3);
        % Duration of stimulus blocks in units of temporal resolution of
        % the design matrix:
        var_dur_blk_stim = int64(var_dur_blk_stim / var_tmp_res);
        % Duration of rest blocks in units of temporal resolution of the
        % design matrix:
        vec_dur_blk_rest = int64(vec_dur_blk_rest / var_tmp_res);
        % Conversion of the experiment duration into units of the design
        % matrix:
        var_dur_exp = var_dur_exp / var_tmp_res;
        % Conversion of the target jitter into units of the design matrix:
        var_jit_target = var_jit_target / var_tmp_res;
        % Conversion of the inter-trial interval for the targets into units
        % of the design matrix:
        var_iti_target = var_iti_target / var_tmp_res;
        % Conversion of the duration of the no-target interval (at the
        % beginning and at the end of the experiment) into units of the
        % design matrix:
        var_no_target = var_no_target / var_tmp_res;
        % This is the range over which the target events will be jittered,
        % units are time points in the design matrix:
        var_jit_range = (var_dur_exp - (2 * var_no_target));
        % Number target presentations:
        var_num_target = floor(var_jit_range / var_iti_target);
        % The jitter of target events & rest onsets only works with an even
        % number of target events & stimulus blocks, and with an uneven
        % number of possible durations of the rest blocks:
        if mod(var_num_target, 2) == 0 && ...
                mod(var_num_blk_stim, 2) == 0 && ...
                mod(var_num_rest_dur, 2) == 1
            %% Jitter rest events:
            % Matrix that will be filled with duration of the  rest blocks
            % (two columns - the first one for an index, the second for the
            % rest block duration, the third for the rest block onset
            % time):
            mat_rest_jit = zeros(var_num_blk_rest, 3);
            % Conversion of the mean rest block duration into units of the
            % design matrix:
            var_dur_blk_rest_mean = int64(...
                var_dur_blk_rest_mean / var_tmp_res);
            % Fill the second column of the matrix with the mean rest block
            % duration:
            mat_rest_jit(:,2) = var_dur_blk_rest_mean;
            % The first rest block has a fixed duration. The possible
            % durations of the remaining rest blocks will be allocated so
            % that the overall mean duration of the blocks stays the same.
            % For that we have to take the modulus of the number of rest
            % blocks and the number of possible durations - the number of
            % rest blocks remaining after division (i.e. the modulus) will
            % be assigned the mean rest block duration.
            var_rest_mod = mod((var_num_blk_rest - 1), var_num_rest_dur);
            % We fill the second column of the matrix with the rest block
            % durations (if necessary leaving out the last rest blocks in
            % order to make sure that the mean rest block duration stays
            % the same):
            index_20 = 1;
            for index_03 = 2:(var_num_blk_rest - var_rest_mod)
                mat_rest_jit(index_03,2) = vec_dur_blk_rest(1, index_20);
                if index_20 < var_num_rest_dur
                    index_20 = index_20 + 1;
                elseif index_20 == var_num_rest_dur
                    index_20 = 1;
                else
                    str_tmp = ['Error - randomisation of rest block ', ...
                        'durations failed.'];
                    disp(str_tmp);
                end
            end
            % We randomly permute the elements in the matrix that contains
            % the rest block durations (leaving out the first rest block):
            mat_rest_jit(2:end,1) = (randperm(var_num_blk_rest - 1) + 1 );
            % The first rest block gets the index number 1, so that it will
            % appear first (and without jitter):
            mat_rest_jit(1,1) = 1; % Index number = 1
            % Sorting the matrix along the first column (which contains
            % randomly assigned index numbers):
            mat_rest_jit = sortrows(mat_rest_jit,1);
            % Initialise temporary variable (for rest block onset time):
            var_tmp_rest_onset = 0;
            % Calculate the onset times the rest blocks:
            for index_01 = 1:var_num_blk_rest
                % The first rest block is an exception, because its onset
                % time is one:
                if index_01 == 1
                    mat_rest_jit(index_01,3) = 1;
                elseif index_01 > 1
                    % Rest block onset times:
                    var_tmp_rest_dur = ...
                        mat_rest_jit((index_01-1),2);
                    var_tmp_rest_onset = (...
                        var_tmp_rest_onset + ...
                        var_tmp_rest_dur + ...
                        var_dur_blk_stim);
                    mat_rest_jit(index_01,3) = var_tmp_rest_onset;
                else
                    str_tmp = ['Error - calculation of rest block ' ...
                        'times failed.'];
                    disp(str_tmp);
                end
            end
            %% Insert rest/stimulus blocks into the design matrix:
            % The first column of the design matrix should contain a boxcar
            % function for stimulus events (zeros for rest, ones for
            % stimulus blocks). We set the first column of the design
            % matrix to one, and then reset it to zeros for rest intervals:
            mat_design(:,1) = 1;
            for index_02 = 1:var_num_blk_rest
                % Temporary variable for rest block onset:
                var_tmp_rest_onset = mat_rest_jit(index_02,3);
                % Temporary variable for rest block duration:
                var_tmp_rest_dur = mat_rest_jit(index_02,2);
                % Set the first row of the design matrix to zero for rest
                % blocks:
                mat_design(...
                    (...
                    var_tmp_rest_onset:...
                    (var_tmp_rest_onset + var_tmp_rest_dur - 1)), ...
                    1 ...
                    ) = 0;
            end
            % The onset of the first stimulus block is special in terms of
            % indexing, this needs to be adjusted.
            mat_design(mat_rest_jit(1,2),1) = 1;
            % The last entry in the design matrix belongs to the rest
            % condition:
            mat_design(end,1) = 0;
            % The seconds column of the design matrix shall contain the
            % target events. However, we first need to jitter the target
            % events.
            %% Jitter target events:
            % Vector containing the actual inter-trial intervals for every
            % occurence of the target:
            vec_iti_list_1 = zeros(var_num_target, 1);
            vec_iti_list_1(:,1) = (var_iti_target - var_jit_target);
            % Vector containing the deviation from the average ITI for
            % every occurence of the target:
            vec_iti_list_2 = zeros(var_num_target, 2);
            % Create the random factors that determine the distribution of
            % the remaining inter-trial time among trials:
            for index_3 = 1:2:var_num_target
                vec_iti_list_2(index_3,2) = rand();
                vec_iti_list_2(index_3,2) = (...
                    round(...
                    vec_iti_list_2(index_3,2) * ...
                    1/var_tmp_res...
                    )...
                    ) * var_tmp_res;
                % The vector consists of pairs of numbers that sum up to 1
                % (i.e. each pair sum up to 1):
                vec_iti_list_2((index_3 + 1),2) = ...
                    (1 - vec_iti_list_2(index_3,2));
            end
            % We randomly permute the elements in the vector that
            % determines the distribution of the remaining inter-trial time
            % among trials:
            vec_iti_list_2(:,1) = randperm(var_num_target);
            vec_iti_list_2 = sortrows(vec_iti_list_2, 1);
            vec_iti_list_2(:,2) = ...
                (vec_iti_list_2(:,2) * var_jit_target * 2);
            % Add the random elements to the fixed component of the IIT:
            vec_iti_list_1(:,1) = ...
                vec_iti_list_1(:,1) + vec_iti_list_2(:,2);
            %% Insert target events into design matrix:
            var_temp = var_no_target;
            for index_4 = 1:var_num_target
                var_temp = var_temp + vec_iti_list_1(index_4,1);
                mat_design(var_temp,2) = 1;
            end
            clear var_temp;
            %% Check for minimum time interval target-rest/stimulus
            % We have to make sure that target events are not directly
            % followed by rest/stimulus onsets within specified time
            % interval (var_int_events). Convert the minimum interval
            % between events into the temporal resolution of the design
            % matrix:
            var_int_trgt_blk = var_int_trgt_blk / var_tmp_res;
            % Likewise, convert the minimum interval between rest/stimulus
            % onset and target onset into the temporal resolution of the
            % design matrix:
            var_int_blk_trgt = var_int_blk_trgt / var_tmp_res;
            % We create a vector that will contain the results of the
            % logical test (for target events being followed by
            % rest/stimulus onsets too close in time):
            vec_boo_1 = zeros(1,var_num_target);
            index_11 = 1;
            for index_10 = 1:var_num_timepoints
                % Search for target event in design matrix:
                if mat_design(index_10,2) == 1
                    % This vector (vec_temp) contains the data from the
                    % first column of the design matrix, i.e. zeros if
                    % there is no stimulus (rest condition) or ones when
                    % there is a stimulus at that time point. NOTE: We add
                    % another time interval (e.g. 300 ms), making sure that
                    % there is also no rest/stimulus onset directly before
                    % a target event:
                    vec_temp = mat_design(...
                        (...
                        (index_10 - var_int_blk_trgt):...
                        (index_10 + var_int_trgt_blk)...
                        ), ...
                        1);
                    % Logical test whether there is a transition between
                    % rest condition & stimulus condition too close in time
                    % to the target event:
                    vec_boo_1(1,index_11) = ...
                        (ismember(0,vec_temp) && ismember(1,vec_temp));
                    index_11 = index_11 + 1;
                end
            end
            % Test whether target events and rest/stimulus events occur
            % together within specified time interval (var_int_events):
            if not(ismember(1,vec_boo_1))
                % We only want to create plots once the design matrix has
                % been shown to fulfill all our criteria. Therefore, we
                % save a copy of the design matrix here that can be plotted
                % later (the main version of the matrix is manipulated in
                % what follows):
                mat_design_copy_01 = mat_design;
                %% Append design matrix - time stamps in seconds
                for index_5 = 1:length(mat_design)
                    % The third column of the design matrix now contains
                    % time in seconds:
                    mat_design(index_5,3) = index_5 * var_tmp_res;
                end
                %% Create an array with the timepoints of events
                % Event matrix: Column 1 = name of event, column 2 = start
                % of event (seconds from beginning of script), column 3 =
                % duration of event (seconds). The number of events in the
                % event matrix:
                var_num_events = var_num_blk_stim + var_num_blk_rest + ...
                    var_num_target;
                mat_events = zeros(var_num_events, 3);
                mat_events(1,1) = 1; % 1 = rest
                mat_events(1,2) = 0;
                mat_events(1,3) = mat_rest_jit(1,2) * var_tmp_res;
                % An index that is used to access elements in the event
                % matrix (which is create below). The index starts at 2
                % because the first entry in the event matrix is an
                % exception, and is already defined above:
                index_6 = 2;
                % An index that is used to count rest events in the event
                % matrix. This is needed because the rest events are
                % jittered, and during the creation of the event matrix we
                % have to refer to the vector 'mat_rest_jit' with this
                % index:
                index_18 = 2;
                disp('Creating event matrix.');
                for index_7 = 1:(length(mat_design)-1)
                    % Stimulus onset:
                    if (mat_design(index_7,1) == 0 && ...
                            mat_design((index_7+1),1) == 1)
                        % Event ID:
                        mat_events(index_6,1) = 3; % 3 = stimulus event
                        % Event onset:
                        mat_events(index_6,2) = ...
                            mat_design((index_7+1),3);
                        % Event duration:
                        mat_events(index_6,3) = ...
                            double(var_dur_blk_stim) * var_tmp_res;
                        index_6 = index_6 + 1;
                        % In case a target event occurs at the same time
                        % point as a stimulus onset:
                        if (mat_design(index_7,2) == 0 && ...
                                mat_design((index_7+1),2) == 1)
                            % Event ID:
                            mat_events(index_6,1) = 2; % 2 = target event
                            % Event onset:
                            mat_events(index_6,2) = ...
                                mat_design((index_7+1),3);
                            % Event duration:
                            mat_events(index_6,3) = var_dur_target;
                            index_6 = index_6 + 1;
                            disp('Note: A target event occurs at the same time point as a stimulus onset.');
                        end
                        % Rest onset:
                    elseif (mat_design(index_7,1) == 1 && ...
                            mat_design((index_7+1),1) == 0)
                        % Event ID:
                        mat_events(index_6,1) = 1; % 1 = rest
                        % Event onset:
                        mat_events(index_6,2) = ...
                            mat_design((index_7+1),3);
                        % Event duration:
                        mat_events(index_6,3) = ...
                            (...
                            mat_rest_jit(index_18,2)...
                            ) * var_tmp_res;
                        index_18 = index_18 + 1;
                        index_6 = index_6 + 1;
                        % In case a target event occurs at the same time
                        % point as a rest onset:
                        if (mat_design(index_7,2) == 0 && ...
                                mat_design((index_7+1),2) == 1)
                            % Event ID:
                            mat_events(index_6,1) = 2; % 2 = target event
                            % Event onset:
                            mat_events(index_6,2) = ...
                                mat_design((index_7+1),3);
                            % Event duration:
                            mat_events(index_6,3) = var_dur_target;
                            index_6 = index_6 + 1;
                            disp('Note: A target event occurs at the same time point as a rest onset.');
                        end
                        % Target event:
                    elseif (mat_design(index_7,2) == 0 && ...
                            mat_design((index_7+1),2) == 1)
                        % Event ID:
                        mat_events(index_6,1) = 2; % 2 = target event
                        % Event onset:
                        mat_events(index_6,2) = mat_design(index_7,3);
                        % Event duration:
                        mat_events(index_6,3) = var_dur_target;
                        index_6 = index_6 + 1;
                    end
                end
                disp('Done.');
                if length(vec_gamma_01) < length(mat_design(:,1)')
                    % The gamma function should be defined over a shorter
                    % time period than the design matrix. We increase the
                    % length of the gamma functions, adding zeros at the
                    % end:
                    vec_gamma_02 = [vec_gamma_01, ...
                        zeros(...
                        1, ...
                        (length(mat_design(:,1)') - length(vec_gamma_01))...
                        )...
                        ];
                    %% Convolution of design matrix with gamma function:
                    % The first column of the design matrix (stimulus
                    % events):
                    disp('Convolving design matrix with gamma function.');
                    mat_temp = (conv(vec_gamma_02, mat_design(:,1)'))';
                    disp('Done.');
                    % The convolution produces a vector that is twice as
                    % long as the input vectors. We cut off the second
                    % half:
                    mat_temp = mat_temp(1:(length(mat_design(:,1))),1);
                    mat_design(:,1) = mat_temp;
                    % Normalise convolved design matrix to 1:
                    mat_design(:,1) = ...
                        mat_design(:,1) ./ max(mat_design(:,1));
                    clear mat_temp;
                    % The second column of the design matrix (target
                    % events):
                    mat_temp = (conv(vec_gamma_02, mat_design(:,2)'))';
                    % The convolution produces a vector that is twice as
                    % long as the input vectors. We cut off the second
                    % half:
                    mat_temp = mat_temp(1:(length(mat_design(:,2))),1);
                    mat_design(:,2) = mat_temp;
                    % Normalise convolved design matrix to 1:
                    mat_design(:,2) = ...
                        mat_design(:,2) ./ max(mat_design(:,2));
                    clear mat_temp;
                    % Calculate correlation between sitmulus and target
                    % events:
                    var_cor = corr2(mat_design(:,1), mat_design(:,2));
                    % -----------------------------------------------------
                    %% Check whether correlation is low enough:
                    % Only continue if the correlation between
                    % target/stimulus events is below threhold, otherwise
                    % repeat:
                    if abs(var_cor) <= var_cor_threshold
                        % Now that we have made sure that the design matrix
                        % fullfills the correlation criterion,
                        % pseudo-randomise the order of stimulus levels (if
                        % there is more than one stimulus level).
                        % Subsequently, we create plots of the design
                        % matrix and of the gamma function.
                        %% Pseudo-randomisation of stimulus levels:
                        % If there is more than one stimulus level (i.e. in
                        % a parametric design), the order of these stimulus
                        % levels in the design matrix will be
                        % pseudo-randomised. In a simple block design with
                        % just one stimulus level, this randomisation is
                        % not performed.
                        if var_stim_levels > 1
                            str_tmp = ['Parametric design with ', ...
                                'more than one stimulus level. ', ...
                                'Will use pseudo-randomisation ', ...
                                'for stimulus levels.'];
                            disp(str_tmp);
                            var_rndmstn = 0;
                            while var_rndmstn ~= 1
                                % Matrix that will contain the time points
                                % of the stimulus events:
                                mat_events_stim = ...
                                    zeros(var_num_blk_stim, 2);
                                % The first row of the matrix contains the
                                % indices of the stimulus events in the
                                % event matrix (mat_events):
                                mat_events_stim(:,1) = ...
                                    find(mat_events(:,1) == 3);
                                % We create a matrix that contains the
                                % stimulus levels. This matrix will then be
                                % premuted randomly. The first column of
                                % the matrix contains a random permutation
                                % of indixes ranging from one to the number
                                % of stimulus events.
                                mat_stim_levels = ...
                                    zeros(var_num_blk_stim, 2);
                                mat_stim_levels(:,1) = ...
                                    randperm(var_num_blk_stim);
                                % The second row of the matrix contains the
                                % event type. Since rest = 1 and target =
                                % 2, the stimulus levels are coded as 3, 4,
                                % etc.. Therefore, we start assigning
                                % stimulus levels with 3:
                                var_stm_lvl_strt = 3;
                                index_14 = var_stm_lvl_strt;
                                for index_15 = 1:var_num_blk_stim
                                    mat_stim_levels(index_15,2) = index_14;
                                    if index_14 < (var_stim_levels + ...
                                            var_stm_lvl_strt -1)
                                        index_14 = index_14 + 1;
                                    elseif index_14 == (...
                                            var_stim_levels + ...
                                            var_stm_lvl_strt - 1)
                                        index_14 = 3;
                                    else
                                        str_tmp = ['Error. Pseudo-', ...
                                            'randomisation of ', ...
                                            'stimulus levels failed.'];
                                        disp(str_tmp);
                                    end
                                end
                                % We sort the matrix according to the
                                % randomly permutet indixes in its first
                                % column:
                                mat_stim_levels = ...
                                    sortrows(mat_stim_levels, 1);
                                % The order of stimulus events in the event
                                % matrix is pseudo-randomly permuted. If
                                % there are two stimulus levels, that's it.
                                % If there are three or more stimulus
                                % levels, their order will be
                                % pseudo-randomised, with the condition
                                % that the same stimulus level does not
                                % appear twice in succession. The following
                                % if clause makes sure that this condition
                                % is only checked if there are more than
                                % two stimulus levels.
                                if var_stim_levels > 2
                                    % We have to check whether the
                                    % pseudo-randomisation condition is
                                    % fulfilled, i.e. whether the same
                                    % stimulus event does not occur twice
                                    % in succession:
                                    var_tmp_switch = 0;
                                    for index_16 = 1:(var_num_blk_stim - 1)
                                        % Test whether there is any element
                                        % for which (n == n + 1):
                                        if mat_stim_levels(index_16,2) == ...
                                                mat_stim_levels(...
                                                (index_16 + 1),2)
                                            % ...if yes, switch the switch:
                                            var_tmp_switch = 1;
                                            str_tmp = ...
                                                ['Randomisation ', ...
                                                'condition not ', ...
                                                'fullfilled. Will ', ...
                                                'try again.'];
                                            disp(str_tmp);
                                        end
                                    end
                                    % If the switch has not been switched,
                                    % the pseudo-randomisation condition
                                    % has been fulfilled:
                                    if var_tmp_switch == 0
                                        var_rndmstn = 1;
                                        str_tmp = ['Randomisation ', ...
                                            'condition fullfilled.'];
                                        disp(str_tmp);
                                    end
                                else
                                    str_tmp = ['Parametric design ', ...
                                        'with two stimulus levels. ', ...
                                        'Will use pseudo-', ...
                                        'randomisation for stimulus ', ...
                                        'levels.'];
                                    disp(str_tmp);
                                    var_rndmstn = 1;
                                end
                            end
                            % We insert the pseudo-random order of stimulus
                            % levels into the matrix with that contains the
                            % indices of the stimulus events:
                            mat_events_stim(:,2) = ...
                                mat_stim_levels(:,2);
                            % Finally, we insert the pseudo-random order of
                            % stimulus levels into the event matrix, based
                            % on their indices:
                            for index_17 = 1:var_num_blk_stim
                                % Variable that temporarily represents the
                                % index of the stimulus event:
                                var_tmp_indx = ...
                                    mat_events_stim(index_17,1);
                                % Variable that temporarily represents the
                                % stimulus level:
                                var_tmp_stmlvl = ...
                                    mat_events_stim(index_17,2);
                                % We put the stimulus levels into the event
                                % matrix:
                                mat_events(var_tmp_indx,1) = ...
                                    var_tmp_stmlvl;
                            end
                        end
                        %% Plot the design matrix (before convolution):
                        var_font_size = 9;
                        % Stimulus events:
                        plt_1 = figure(...
                            'units', ...
                            'normalized', ...
                            'outerposition', ...
                            [0 0 1 1]);
                        axs_1 = subplot(2,1,1);
                        grp_1 = plot(...
                            linspace(...
                            1, ...
                            length(mat_design_copy_01), ...
                            length(mat_design_copy_01)...
                            ), ...
                            mat_design_copy_01(:,1)'...
                            );
                        lgn_1 = legend(grp_1, 'Stimulus events');
                        set(axs_1, 'YLim', [-0.1, 1.1]);
                        % If there is more than one stimulus level, we add
                        % labels for the stimulus levels to the plot of the
                        % stimulus events:
                        if var_stim_levels > 1
                            for index_19 = 1:var_num_blk_stim
                                % We use the information in the matrix
                                % mat_events_stim to access the indices of
                                % the stimulus events in the design matrix:
                                var_tmp_stim_event_indx = ...
                                    mat_events_stim(index_19,1);
                                % We also use the information from the
                                % matrix mat_events_stim to access the
                                % event identity:
                                var_tmp_stim_event_lvl = ...
                                    mat_events_stim(index_19,2);
                                % The stimulus events are coded as 3, 4,
                                % ... in the event matrix. We would like
                                % the labels to be in the form 1, 2, ... .
                                % Therefore, we subtract 2 from the labels
                                % in the event matrix:
                                var_tmp_stim_event_lvl = ...
                                    var_tmp_stim_event_lvl - 2;
                                % We access the time of the stimulus event
                                % from the event matrix. We need to convert
                                % this time (which is in seconds) to time
                                % units of the design matrix in order to
                                % place the text on the graph:
                                var_tmp_stim_event_tme = (...
                                    mat_events(...
                                    var_tmp_stim_event_indx, 2) / ...
                                    var_tmp_res);
                                % Creation of the text:
                                txt_1 = text(...
                                    (var_tmp_stim_event_tme + ...
                                    (3 / var_tmp_res)), ...
                                    0.9, ...
                                    num2str(var_tmp_stim_event_lvl)...
                                    );
                                set(txt_1, ...
                                    'FontName', 'Courier New', ...
                                    'FontSize', var_font_size, ...
                                    'HorizontalAlignment', 'left');
                            end
                        end
                        % Target events:
                        axs_2 = subplot(2,1,2);
                        grp_2 = plot(...
                            linspace(...
                            1, ...
                            length(mat_design_copy_01), ...
                            length(mat_design_copy_01)...
                            ), ...
                            mat_design_copy_01(:,2)'...
                            );
                        lgn_2 = legend(grp_2, 'Targets');
                        set(axs_2, 'YLim', [-0.1, 1.1]);
                        %% Plot a graph to visualise the gamma function:
                        plt_3 = figure(...
                            'units', ...
                            'normalized', ...
                            'outerposition', ...
                            [0 0 1 1]);
                        axs_3 = axes;
                        grp_3 = plot(...
                            axs_3, ...
                            linspace(...
                            1, ...
                            length(vec_gamma_01), ...
                            length(vec_gamma_01)...
                            ), ...
                            vec_gamma_01');
                        set(axs_3, 'YLim', [-0.1, 1.1]);
                        lgn_3 = legend(grp_3, 'Gamma function');
                        % We can clear the copy of the design matrix (we
                        % only saved it in order to plot it after the test
                        % for low enough correlation):
                        clear mat_design_copy_01;
                        %% Save event matrix to text file:
                        % 1) Implementation using fprintf: fle_file_ID =
                        % fopen('matlab_eventmatrix.dat', ...
                        %     'w');
                        % str_output_format = '%d %d %d\n'; for index_8 =
                        % 1:var_num_events
                        %      fprintf(fle_file_ID , ...
                        %          str_output_format, ...
                        %          mat_events{index_8,:});
                        % end 2) Implementation using dlmwrite:
                        dlmwrite([str_output_path, ...
                            str_prefix, ...
                            '_eventmatrix.txt'], ...
                            mat_events, ' ');
                        %% Plot the design matrix (after convolution):
                        plt_4 = figure(...
                            'units', ...
                            'normalized', ...
                            'outerposition', ...
                            [0 0 1 1]);
                        axs_4 = subplot(2,1,1);
                        grp_4 = plot(...
                            linspace(...
                            1, ...
                            length(mat_design), ...
                            length(mat_design)...
                            ), ...
                            mat_design(:,1)'...
                            );
                        lgn_4 = legend(grp_4, 'Stimulus events');
                        set(axs_4, 'YLim', [-0.1, 1.1]);
                        axs_5 = subplot(2,1,2);
                        grp_5 = plot(...
                            linspace(...
                            1, ...
                            length(mat_design), ...
                            length(mat_design)...
                            ), ...
                            mat_design(:,2)'...
                            );
                        lgn_5 = legend(grp_5, 'Targets');
                        set(axs_5, 'YLim', [-0.1, 1.1]);
                        %% Calculate overlap btwn stimulus & target events:
                        % Create graph:
                        vec_product = (mat_design(:,1) .* mat_design(:,2));
                        plt_6 = figure(...
                            'units', ...
                            'normalized', ...
                            'outerposition', ...
                            [0 0 1 1]);
                        axs_6 = axes;
                        grp_6 = plot(...
                            linspace(...
                            1, ...
                            length(vec_product), ...
                            length(vec_product)...
                            ), ...
                            vec_product(:,1)'...
                            );
                        lgn_6 = legend(grp_6, ...
                            'Overlap stimulus/target events');
                        set(axs_6, 'YLim', [-0.1, 1.1]);
                        % Calculate normalised overlap per timepoint:
                        var_norm_ovrl = ...
                            sum( mat_design(:,1) .* mat_design(:,2) ) / ...
                            sum( mat_design(:,1) .* mat_design(:,1) );
                        % Calculate correlation between sitmulus and target
                        % events: Create and display message:
                        str_msg_1 = ['The normalised overlap is ', ...
                            num2str(var_norm_ovrl), ...
                            '. The correlation coefficient is ', ...
                            num2str(var_cor), '.'];
                        txt_6 = text((0.5 * length(vec_product)), ...
                            -0.35, str_msg_1, ...
                            'HorizontalAlignment', 'center', ...
                            'FontName', 'Courier', ...
                            'FontSize', 9);
                        %% Prepare and save figures:
                        % Cell array with output file names:
                        ary_filenames = {...
                            [str_prefix, '_01_design_matrix'], ...
                            [str_prefix, '_02_gamma_function'], ...
                            [str_prefix, '_03_design_matrix_convolved'], ...
                            [str_prefix, '_04_overlap']};
                        % Settings for graphs:
                        vec_y_scale = [-0.2, 1.2];
                        % NOTE: The labelling of the axes may have to be
                        % adjusted if the length of the run is changed:
                        vec_x_tick = ((0:50:var_dur_exp)/var_tmp_res);
                        % NOTE: The labelling of the axes may have to be
                        % adjusted if the length of the run is changed:
                        vec_x_tick_labels = (0:50:var_dur_exp);
                        % Adjust axis 1:
                        var_temp_xlabel = get(axs_1, 'XLabel');
                        var_temp_ylabel = get(axs_1, 'YLabel');
                        set(var_temp_xlabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Time [s]');
                        set(var_temp_ylabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Modulation [normalised]');
                        set(axs_1, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'XLimMode', 'manual', ...
                            'XLim', [0, (length(mat_design) + 100)], ...
                            'YLimMode', 'manual', ...
                            'YLim', vec_y_scale, ...
                            'XTickLabelMode', 'manual', ...
                            'XTickMode', 'manual', ...
                            'XTick', vec_x_tick, ...
                            'XTickLabel', vec_x_tick_labels);
                        % Adjust axis 2:
                        var_temp_xlabel = get(axs_2, 'XLabel');
                        var_temp_ylabel = get(axs_2, 'YLabel');
                        set(var_temp_xlabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Time [s]');
                        set(var_temp_ylabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Modulation [normalised]');
                        set(axs_2, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'XLimMode', 'manual', ...
                            'XLim', [0, (length(mat_design) + 100)], ...
                            'YLimMode', 'manual', ...
                            'YLim', vec_y_scale, ...
                            'XTickLabelMode', 'manual', ...
                            'XTickMode', 'manual', ...
                            'XTick', vec_x_tick, ...
                            'XTickLabel', vec_x_tick_labels);
                        % Adjust axis 3:
                        var_temp_xlabel = get(axs_3, 'XLabel');
                        var_temp_ylabel = get(axs_3, 'YLabel');
                        set(var_temp_xlabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Time [s]');
                        set(var_temp_ylabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Modulation [normalised]');
                        vec_x_tick_gamma = zeros(1,11);
                        vec_x_tick_labels_gamma = zeros(1,11);
                        index_13 = 1;
                        for index_12 = 0.0:0.1:1.0
                            vec_x_tick_gamma(1, index_13) = ...
                                index_12 * (40/var_tmp_res);
                            vec_x_tick_labels_gamma(1, index_13) = ...
                                index_12 * (40/var_tmp_res ) * ...
                                var_tmp_res;
                            index_13 = index_13 + 1;
                        end
                        set(axs_3, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'XLimMode', 'manual', ...
                            'XLim', [0, (40/var_tmp_res + 100)], ...
                            'YLimMode', 'manual', ...
                            'YLim', vec_y_scale, ...
                            'XTickLabelMode', 'manual', ...
                            'XTickMode', 'manual', ...
                            'XTick', vec_x_tick_gamma, ...
                            'XTickLabel', vec_x_tick_labels_gamma);
                        % Adjust axis 4:
                        var_temp_xlabel = get(axs_4, 'XLabel');
                        var_temp_ylabel = get(axs_4, 'YLabel');
                        set(var_temp_xlabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Time [s]');
                        set(var_temp_ylabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Modulation [normalised]');
                        set(axs_4, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'XLimMode', 'manual', ...
                            'XLim', [0, (length(mat_design) + 100)], ...
                            'YLimMode', 'manual', ...
                            'YLim', vec_y_scale, ...
                            'XTickLabelMode', 'manual', ...
                            'XTickMode', 'manual', ...
                            'XTick', vec_x_tick, ...
                            'XTickLabel', vec_x_tick_labels);
                        % Adjust axis 5:
                        var_temp_xlabel = get(axs_5, 'XLabel');
                        var_temp_ylabel = get(axs_5, 'YLabel');
                        set(var_temp_xlabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Time [s]');
                        set(var_temp_ylabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Modulation [normalised]');
                        set(axs_5, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'XLimMode', 'manual', ...
                            'XLim', [0, (length(mat_design) + 100)], ...
                            'YLimMode', 'manual', ...
                            'YLim', vec_y_scale, ...
                            'XTickLabelMode', 'manual', ...
                            'XTickMode', 'manual', ...
                            'XTick', vec_x_tick, ...
                            'XTickLabel', vec_x_tick_labels);
                        % Adjust axis 6:
                        var_temp_xlabel = get(axs_6, 'XLabel');
                        var_temp_ylabel = get(axs_6, 'YLabel');
                        set(var_temp_xlabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Time [s]');
                        set(var_temp_ylabel, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'String', 'Overlap [normalised]');
                        set(axs_6, ...
                            'FontName', 'Courier New', ...
                            'FontSize', var_font_size, ...
                            'XLimMode', 'manual', ...
                            'XLim', [0, (length(mat_design) + 100)], ...
                            'YLimMode', 'manual', ...
                            'YLim', vec_y_scale, ...
                            'XTickLabelMode', 'manual', ...
                            'XTickMode', 'manual', ...
                            'XTick', vec_x_tick, ...
                            'XTickLabel', vec_x_tick_labels);
                        for index_8 = 1:4
                            if index_8 == 1
                                fig_temp = plt_1;
                                tlt_temp = ary_filenames{1};
                            elseif index_8 == 2
                                fig_temp = plt_3;
                                tlt_temp = ary_filenames{2};
                            elseif index_8 == 3
                                fig_temp = plt_4;
                                tlt_temp = ary_filenames{3};
                            elseif index_8 == 4
                                fig_temp = plt_6;
                                tlt_temp = ary_filenames{4};
                            else
                                disp('Fatal error 42.')
                            end
                            % Initialising parameters & figure size:
                            set(fig_temp, ...
                                'Units', 'normalized', ...
                                'Position', [0 0 1 1], ...
                                'PaperUnits', 'points', ...
                                'PaperSize', [900 500], ...
                                'PaperPosition', [0 0 900 500], ...
                                'Color', [0.95 0.95 0.95], ....
                                'InvertHardcopy', 'off');
                            % File name:
                            set(fig_temp, 'Name', tlt_temp);
                            % Save figure as png file:
                            print(...
                                fig_temp, ...
                                '-dpng', ...
                                [str_output_path, tlt_temp]);
                        end
                    else
                        str_tmp = [...
                            'Correlation threshold exceeded: ', ...
                            num2str(var_cor), ...
                            '. Will try again.'];
                        disp(str_tmp);
                        close all;
                        clearvars -except ...
                            ary_prefix ...
                            str_output_path ...
                            index_9 ...
                            str_prefix ...
                            var_cor_threshold ...
                            var_cor ...
                            var_tmp_res ...
                            vec_gamma_01;
                    end
                else
                    disp('Error. The vector that represents the gamma funciton needs to be shorter than the design matrix.');
                end
            elseif ismember(1, vec_boo_1)
                disp('Target followed by rest/stimulus onset within prohibited time interval. Will try again.');
                disp(['vec_boo_1: ', num2str(vec_boo_1)]);
                clearvars -except ...
                    ary_prefix ...
                    str_output_path ...
                    index_9 ...
                    str_prefix ...
                    var_cor_threshold ...
                    var_cor ...
                    var_tmp_res ...
                    vec_gamma_01;
            else
                disp('Error. Problem with controlling the co-occurence of targets and rest/stimulus events within prohibited time interval (var_int_events).')
                clearvars -except ...
                    ary_prefix ...
                    str_output_path ...
                    index_9 ...
                    str_prefix ...
                    var_cor_threshold ...
                    var_cor ...
                    var_tmp_res ...
                    vec_gamma_01;
            end
        else
            disp('Error. The jitter of target events only works with an even number of target events and stimulus blocks and with an uneven number of possible rest block durations.');
        end
    end
    % Save workspace: str_temp = strcat(str_output_path, str_prefix,
    % 'mat_workspace');
    % save([str_output_path, str_prefix, 'mat_workspace']);
    close all;
    clearvars -except ...
        ary_prefix ...
        str_output_path ...
        index_9 ...
        var_tmp_res ...
        var_cor_threshold ...
        var_tmp_res ...
        vec_gamma_01;
    pause(1);
end
toc;
